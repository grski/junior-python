\pagebreak

# Recruitment

Everything related to recruitment.

## What the Process Looks Like

Generally, recruitment processes vary quite a bit, but they usually consist of similar building blocks. Some are quite short, others are long. The most common pattern, however, is a recruitment process that follows this style...

### The Details

First, there will be a phone call or Skype interview. At this stage, you might already face some technical tasks or questions aimed at filtering out candidates who are completely unsuitable for the job. However, at this stage, the questions are usually simple and asked by a non-technical person. Most questions, at least from my experience, will be about you and your professional profile - what you've done, what you want to do, where you're headed, why you're changing companies.

Contrary to appearances, these things also matter because it's important to know what kind of candidate you are, what your character is like, and whether you'll be pleasant to work with. Really. It's worth noting that your personality matters more in smaller companies. What I mean is that in a large company, there are many different teams with different dynamics, so there's a much better chance you'll fit in somewhere. In a small company, it's harder - you need to be a better fit.

Does this mean you'll be hired solely based on your personality? No. It's not THAT important. Remember one thing - don't be a jerk. Simple as that.

Does this mean you should pretend to be someone you're not? Definitely not. If you put on an act during the interview, the truth will come out during work anyway. You'll suffer, the employer will suffer. Why bother?

Next, there might be an in-person meeting or a take-home assignment in the form of a project or a Codility-type test.

During the in-person meeting, you should expect more specific questions. At this point, a technical person will usually join or lead the conversation. What kind of questions can you expect? Well, it depends.

It's obvious that no one will ask you about things that aren't in your CV or things completely unrelated to the position. That's clear. If they do, it's a bit unprofessional on the interviewer's part.

As for the things that ARE in your CV, you can safely assume that someone might quiz you on every word you've included. Additionally, there are certain questions about general computer science, algorithms, or database basics that often come up, regardless of the position or company.

Naturally, it's worth considering the specific job posting you're applying for and the company's profile. If it's a company that largely deals with database topics, it's obvious that you can expect questions in that area.

A small note before we continue: some tasks are designed so that you won't be able to solve them. Sometimes you'll need to ask clarifying questions, sometimes it won't be possible at all. Some recruiters use such techniques, or others, introducing some stressful element during the task to see how a candidate handles pressure.

An example of this might be trying to convince you that your correct solution is wrong, or some interruption during problem-solving meant to distract you. This is quite rare, but I've heard of such practices, so be aware, although I doubt anyone would use something like this on a Junior candidate.

If you're unsure about something, ask. Don't be shy. Make sure you understand the task correctly, give an example, and ask if that's what they mean. It's not like you get penalty points for every question you ask. It shows that you're not afraid to ask and communicate. That's a plus in my book.

I'll give you a list of interview questions I've encountered a bit later.

After that, there might be more interviews or not. In any case, after some time, if the company has a normal approach to candidates, you should receive some feedback about whether you succeeded or not, and if not, what you could work on.

In short: a typical recruitment process can be divided into:
- A chat about you and your experiences
- A technical interview
- Optionally, a take-home assignment

I'll confide that nowadays I'm becoming quite picky - if a recruiter sends me an assignment that will take me several hours, I... Thank them and withdraw. And I'm not saying this from a place of arrogance. I don't think I'm some big shot, absolutely not.

I simply value my time, because those few hours I spend solving it will be gone forever. Besides, in my free time, I prefer to program things I actually want to work on, not some boring recruitment project.

However, you, at the beginning, when you're going to or looking for your first job or simply don't have much experience - you can't be picky.

An exception to this rule are assignments from IT giants. I haven't had the chance to work for such companies, and I haven't heard that they use such practices anyway.

### What Questions Will Come Up?

How do recruiters determine questions? Is there some list that everyone picks from? From my experience and conversations with others, it turns out that... no.

Such lists don't really exist. Recruiters simply ask questions that... someone once asked them. They have a few favorite questions, sometimes they share them among themselves, and that's it. Of course, there are some standard example questions that appear everywhere, but you'll find those in the question list I've included in this book below.

There aren't really any secret internal company lists containing questions for potential employees. So don't waste your effort looking for them. You simply need to be prepared, that's all. However, it's worth noting that if a company frequently works on REST APIs, they'll probably ask about that. Generally, a good tip is to look at the company's project profile and see what they deal with daily, then prepare for that. If a company works in Python, they won't be asking about Java technologies.

What does being prepared mean? It's not just knowing specific topics, no. Job interviews are difficult, often stressful, especially if you really want the position. All of this hugely affects how you'll work on the given task. That's one thing. Two, a common problem is that someone knows a topic but can't apply it in practice.

Just reading, I don't know, Cormen's algorithms book, isn't enough. These aren't academic studies or debates, but rather concrete problems for which you'll need to find solutions. Besides, are you surprised? Your recruiter probably last dealt with such deep theory when they were finishing their own studies and probably doesn't remember it today, so naturally they won't ask about that. They'll ask about specific applications, specific problems.

So let me repeat: to be prepared, it's not enough to know or be familiar with some topic. You need to be able to apply it really well in practice, because during an interview, where you'll definitely be stressed, it'll be harder to come up with new ideas. So a really good piece of advice is that certain things should be natural to you, just like multiplication tables. At least I hope they are.

### Not Just Knowledge

Also remember that a programmer is not just some encyclopedia or code-churning machine. A programmer is also, and in fact primarily, a human being, and in people's lives, communication and other soft skills are important. Very important. Especially when you're starting as a Junior. Pay attention to this during the interview and try to be communicative. I repeat my appeal - don't be a jerk. In short, DBJ.

You can be a really great programmer, but if you're unpleasant to work with, the employer won't be happy, and neither will your team.

This, in turn, will translate to lower productivity, worse atmosphere in the team, and decreased colleague satisfaction. It's better to hire someone who's great to work with, who has a good attitude, knows how to work in a team, and has nice soft skills, because they'll quickly learn the technical stuff if they're reasonably competent. Simple.

It's much harder to teach someone those previously mentioned skills, while technical ones are no problem. So know that your skills aren't everything. Your attitude towards problems and solving them is also very important, fitting into the team, simply being a decent human being, avoiding being an arrogant jerk, and being kind and friendly, but in a way that doesn't let others walk all over you. Just like that.

Don't think I'm exaggerating. I myself witnessed a situation where the most competent person in a given field in a specific team was let go because teamwork was going quite poorly.

Communication is a must, especially in remote work, but... Don't go overboard in the other direction. Don't talk too much. Every additional sentence is a potential opportunity to throw in some complete nonsense that might disqualify you. I know because I speak from experience. You need some common sense and to know when it's better to say a bit less.

Don't overdo it and be professional. At this stage, there isn't always room for excessive familiarity, so don't take that initiative. Currently, as a candidate, you're in a lower status position, so to speak. Show your interviewer proper respect and behave professionally.

It's different if your recruiter suggests upfront that the atmosphere be relaxed and casual. That's usually the case, but it looks better if the senior person proposes moving to informal communication rather than if you, the candidate, force it in a way. That's my advice.

Since we're on this topic, let me also say a few words about attire. I like to follow one rule: it's better to be dressed too elegantly than to show up in flip-flops and embarrass yourself. Your attire also says something about you, as does your overall appearance. Even if you don't like it, unfortunately (or fortunately), our appearance affects how people perceive us, regardless of whether they're aware of it or not.

Here again, common sense will help you, because what you should wear often depends on where you're applying. Obviously, you can dress somewhat differently for an interview at a startup or a new software house versus a huge corporation.

However, I usually dress as follows: black pants, a simple shirt in muted colors, and if it's a more formal meeting, I add a blazer. A fairly safe set that will be appropriate practically everywhere. So remember that although your skills, knowledge, and who you are constitute the main substance and most important thing, presentation also counts. How they see you is how they write you down. There's plenty of research showing that we more readily attribute positive traits to people who look nice, and negative traits to those who look sloppy.

So look presentable, preferably like a normal person, not a stereotypical programmer who was forcibly pulled out of the basement after two weeks of manic gaming. Straighten your back, pull your shoulders back, speak clearly and slowly. When you shake hands, shake hands like a person, not a limp noodle. Speak normally, not almost whispering so you can't be heard. There! Be someone with dignity!

### The Result

What if you don't get in? Well, keep trying, brush up on your skills. Don't give up. Note: sometimes you have to wait a while for an answer. If the recruiter doesn't get back to you the next day, don't worry - it doesn't necessarily mean you didn't get in. Once when I was interviewing, I had the conversation sometime in early June, and we only finalized the job in mid-August, so.

Sometimes you have to wait a week or two, and sometimes the feedback won't come at all. I consider this a bit rude, but unfortunately it's a fairly common practice. Why is something like this disrespectful?

Well, if a candidate dedicated their time, prepared, completed some tasks, and came for an interview, they should at least get some information about the state of their knowledge, about what they did wrong.

It doesn't take much work - just sending information, a simple email, or two minutes on the phone. And, especially for someone just starting out, it can help.

If someone can't even be bothered to do something like that, then... Well, it says something about the company, and you should be glad you don't have to work with such people. On the other hand - if you show up for an interview without any preparation, ignoring your interviewer, then congratulations, you ignored DBJ.

You got in, there's an offer? Great. Only...

What about that terrible question that always comes up somewhere along the way - how much would you like to earn? How to handle this? That's in another chapter.

Same goes for example questions you might encounter.

### Practice

Interviewing is also a skill. At the beginning, you might do mediocre. Even though you'd solve the task under other circumstances, during a live interview stress suddenly takes over, or you freeze. It happens. That's why it's worth practicing and asking someone (e.g., a friend or mentor) to conduct a test interview with you before the real thing. Seriously.

Interviews are also a test of how well you can sell yourself, without lying of course, and a test of your soft skills, negotiation skills. Many times I've earned more than my much more experienced colleagues, just because I wasn't afraid to ask for raises or substantial amounts, plus I came across fairly well in interviews because I often participated in them even just for practice, I conducted them myself, I was good at them. Thanks to this, I could negotiate nice terms surprisingly often.

### Negotiation

People generally don't like to negotiate, which is a shame. A shame because it simply pays off.

My record is a situation where the hiring bonus I got, just by politely asking and hopping on a call for 5 minutes, was substantial. 5 minutes of additional conversation and money in my pocket. Damn, the hourly rate works out pretty nice there.

It's similar with salary. If half an hour of negotiation can get you 5% more salary, let's say even a couple hundred dollars a month, that adds up to a decent amount yearly. Already quite a bit. And remember, that's usually just several minutes.

## Education and Recruitment

When I was looking for my first job, I was a fresh eighteen-year-old, still in my last year of high school. Zero education, experience, nothing. And yet I made it. As you can see, it's possible. I'm mentioning this at the start in case you doubt yourself, to give you some encouragement. If I could do it, you can too, as long as you put in some work and have some luck. Before we get into the details, a few words about education.

### Is the Degree Worthless?

Generally, you might get the impression that I have a negative attitude and talk about university in a pejorative way. Nothing could be further from the truth. I think university can be a wonderful place where you learn a lot and meet wonderful people. However, if you go there just for a piece of paper because your parents said so, you have no idea what you're doing there, you don't learn anything, well then, what's the point?

In that case, yes, the whole endeavor is pointless. You might as well go work at any job because you won't get any benefit from those studies anyway, just suffering.

If, on the other hand, you approach your studies sensibly, they'll only be an asset and not something that can hurt you. Then it's a great opportunity.

### Do I Regret Not Going to University?

Life sort of chose for me; I was somewhat forced into getting a job quickly, that's a fact. So one might ask, do I regret it? No. Having 3 years of experience when my peers were just starting to crawl, still interns, I was already managing a team, meeting wonderful people, and developing industry connections.

I wouldn't trade that for those extra years of carefreeness.

However, I should note that this is just my case. Not everyone will be that lucky. Education is therefore something really worth considering, but it's not a necessary element.

University is a good time to build connections, because it's easier to talk to someone you used to grab drinks with, who's now a Team Leader somewhere, versus freshly met stranger who is a complete unknown. There's no one recipe.

### Does Lack of Education Disqualify Us?

A frequently asked question. Does the lack of a degree disqualify a candidate? Well, my dear friends, if someone judges you only through the lens of your education and not you as a person, the question is whether you want to work with such a company? For me, that's a red flag right away.

In my entire career and currently, let's say dozens of interviews, only once did it happen that a CEO barged into the interview and asked, I quote:

> Why should we hire you if you don't have a degree?

After the technical interview, he already knew why, and they ultimately offered me the job. I politely declined. I don't work with rude people, but you have to maintain class and respect for other people. As if that wasn't enough, a year later they wrote again, asking if maybe something had changed :-)

Fate is ironic sometimes, wanting to play poker with me.

So no, lack of education doesn't determine anything.

## How I Looked for My First Job

A bit about how my search went.

### First-Class Spammer

Generally, my approach, in hindsight not necessarily optimal, was as follows: scour all job listings. Anything related to programming and at least somewhat backend-related? Write to them. This was a few years ago, so there wasn't quite the abundance of job postings as there is now.

I wrote to various companies, sent emails and messages. Even if they weren't looking or if I didn't match the candidate profile. I spammed en masse. It lasted for weeks. I sent at least 80 applications to various companies. I got maybe 8 or 9 responses. 90% didn't even bother with a simple "We'll call you back." I don't blame them.

### Some Results

Nevertheless, from those 8 or 9 responses, I managed to get 3 emails inviting me for an interview. In one case, it was for a regular position (lol), in the second for a junior, and in the third for an internship.

### First Interviews

I failed the first one at the algorithmic test stage. I was 10% short. Oh well, moving on.

The second one, which was for the internship, went like butter. I could already see myself in that job.

Before the scheduled third interview, I got a phone call. The CEO of one of the companies I had spammed found my message in his SPAM folder but read it anyway. It just so happened that I had something in my CV about knowing Python or having used it, and something had just opened up for them, they needed someone to work.

So I said I'd be whatever they wanted me to be, give me that interview. So he did.

That interview didn't go great for me. I expected Python questions, but instead the guy mainly quizzed me on programming basics, data structures, and such, which weren't my forte at the time. Fortunately, I remembered some basics because I had done the Harvard course - CS50, so I managed to string together a few sentences. But in my mind, I was still in chill utopia because in my perception, that second interview had gone perfectly.

### Surprise

Well, it turned out that the internship interview didn't go as well as I thought. They didn't call back. I got a bit sad here, thinking nothing would come of it and I'd have to spam again, I mean apply.

### Surprise Two

Well, someone else called back. The CEO from the SPAM message. He called with the information that I made a good impression; there was still much to improve, of course, but I was a fairly nice guy, so we could work something out.

They offered me remote work, which for me, still in high school, was ideal. The pay, for that time, was also decent compared to similar entry-level work. All things considered.

Taking all that into account, I didn't hesitate for a moment, I agreed immediately and informed the last company I had an interview scheduled with that I'd pass.

### Trial Period

Generally, the deal was that the first two months I had a trial period, and if there was progress, there would be an extension. So what, I rolled up my sleeves and pushed through.

After two months, I got a raise and an extension. I made it.

I was jumping with joy overall. Here once again, besides those thanks at the beginning, I want to thank Jakub Gasiorski and Maciej Mondrzycki. These two people are largely responsible for where I am and who I am. They let me gain first experience, they invested and took some risk, hiring an unknown kid, just turned 18, from high school into a serious company. Kudos.

### Summary

That's how my first job search went. It wasn't ideal. Now I'd do it a bit differently, mainly focusing on fewer companies, writing more personalized messages, putting more effort into my project portfolio on GitHub, making a nice CV, and better preparing for interviews. I recommend the same to you. Choose a few job postings or companies that appeal to you. Write proper messages, even a cover letter, and send them out.

And speaking of CVs...

## CV

A readable, nicely polished CV is half the battle. So let's talk about the art of creating a readable CV. I'm not an expert in this field, but I think I've seen enough CVs to know what's more or less okay and what's not.

### My Latest CV

To not analyze in the abstract, I'll show you an example CV - in this case, mine - which I consider fairly decent.

![First page of CV](./chapters/resources/images/cv_1.png)

![Second page of CV](./chapters/resources/images/cv_2.png)

### Analysis

What does the CV above consist of?

1. Contact Information
   Things like phone number, email address, or city of residence. There's no need to provide an exact address, but sometimes it's worth it so the recruiter knows roughly where you work from.
2. GitHub
   Pretty obvious. A nice portfolio on GitHub helps a lot.
3. Blog
   Obviously, not everyone has one, but I do. I think I have some nice articles, so I linked it. It also gives a sense that I show initiative and do something "extra." When I was recruiting, I always gave some small plus points for something like this. Additionally, having a blog allows the recruiter to read a piece of your writing, to get to know you in some way. I've also had interviews where recruiters openly admitted they weren't necessarily planning to invite me for an interview, but after looking at my blog, they changed their minds. Just remember, no content is better than garbage content posted just to have something. While you stay silent, people don't know you're clueless - that saying applies here. So think twice about what you post on your blog and whether you need one. Nothing by force.
4. Brief Summary
   Here I briefly introduced myself, my values, and previous experiences. Short and sweet.
5. Experience
   A list of jobs I've held. Internships, participation in various projects, etc. can also be included here. Newest at the top, oldest at the bottom. That's the sorting order. Describe example technologies, what challenges there were, what actions were taken, what the result was, and what made this job stand out from others. Tips like that.
6. Skills
   Keywords for recruiters. Recruiters are often non-technical. They might not understand technical jargon, and the only thing they do is scan CVs looking for specific keywords. This is the place to put them. However, it's important not to throw everything in here. If you wrote a hello world in Java, don't add it to your skills. Assume that you'll be quizzed on every skill you put here. If they catch you lying, it's Game Over.
7. Example Projects
   Also pretty clear.
8. Article Recommendations
   If you don't have a blog, skip this. I added such a section because I'm proud of some texts and wanted to showcase them.
9. References
   Also optional.
10. Hobbies(?)
    I don't have this because I had little space due to a large number of entries in Experience. However, as is often the case with Juniors, if your CV is a bit empty, add something about yourself - your hobbies, interests, generally who you are as a person. For a junior/intern position, they're more hiring the person than specific skills anyway because they need to invest. So present yourself in a good light.
11. Data Processing Consent
    At the very bottom in small text is a clause that unfortunately must be added to every CV, otherwise the company cannot process such a document. (Note: This varies by jurisdiction - check what's required in your country.)

### Photo

For the love of god, don't. This isn't a recruitment for a CEO's assistant to include photos. No. There's no need. Adding photos to CVs is not common practice in many countries, including the US and UK.

### Summary

My CV looks how it looks. I've described its elements. This isn't some absolute list, but I think the tips are pretty decent. CV should definitely be in English if you're applying to international companies. It's IT after all; we communicate in English here. Plus, the format should be clean and tidy. As for the font, there's one rule: anything but Comic Sans. I think that's it.

## What I Knew Going to My First Job - A Case Study

Today, specifically what you need to know to get your first job, or rather, what I knew when I was looking for my first job. The title is catchy because different companies have different requirements for juniors, and in one company someone like me is an intern, and in another already a junior - it varies. Nevertheless, this is just my perspective, not some absolute benchmark, but the things below allowed me to become a junior Python dev, so there's that.

In addition, I'll also describe some of my projects that I included in my CV.

Is what I write here necessary or actually sufficient? I don't know. It was enough for me in interviews, but I didn't have too many of them, so my experience is limited. But let's say that for an internship, if you know what's below, you should be able to do it without any problem.

The order I've chosen is rather random. If something is important in my opinion, I clearly indicate it.

### Googling

This is the first and probably most important skill. After all, broadly understood computer science is not about programming, but about... processing information. Part of this process is searching for, analyzing, and using information needed to solve a problem or implement something new. In short - googling. What do I specifically mean by this?

The ability to concisely rephrase errors, searching for information on the right pages. Preferably in English - in this language we'll find the most materials, of course.

It's mainly about not throwing up your hands and stopping when there's a standstill, problem, or error, but doing something, looking for help, information. That's what it's about. 99% of problems are already solved somewhere; you just need to search. If you come across that remaining 1%, you're probably at such an advanced level that we have nothing to discuss.

### English

This is a necessity. We talked about it in one of the first chapters. The multitude of materials available in English, the fact that it's an international language, popularized and ubiquitous, clearly argues that it's necessary for every programmer. I'm sure some people will claim they don't know any foreign languages and they still work. Sure, but where? What kind of company? I don't really know of any respectable companies hiring people without at least basic English.

How can you collaborate with foreign clients, colleagues who often aren't from your country and don't speak your language without it? How do you read documentation, code?

Plus, international companies usually pay better.

What level is needed? Minimally, enough to be able to read technical documentation of some language/framework. That's enough to start.

### Algorithms and Data Structures

Yes, contrary to appearances, you need to know these too. It's supposedly "boring theory" and all that, but... It's a necessity. Not to implement them yourself from scratch, but for two purposes. The first is passing interviews, as you'll often be quizzed on them. The second is awareness of how certain things work under the hood. Which is what I always mention, to the point of nausea.

#### Basic Algorithms

1. Insertion Sort - I probably don't need to explain, a simple sorting algorithm. The basics of basics.

2. Selection Sort - similar to above. Very basic, inefficient.

3. Bubble sort

4. Merge sort

b) searching

5. Linear Search - complete basics

6. Binary Search

That's probably it for the absolute basics. And now note - do I know each of these algorithms exactly by heart, implemented them several times, and used my own modified versions? No. I just know how they work - I know the scheme of their operation, their advantages and disadvantages, when to use which. When not to use a given algorithm, bad cases, and so on. Because that's what's important. Sometimes it drastically changes the speed of our program.

Since we're on algorithms, it's worth mentioning something like **recursion**, which in turn is something you need to know to learn Merge sort or Binary search.

The next important thing is **computational complexity**, or so-called **big O notation**. What's it about? Simply put, it's the number of some "moves" that our program will need to execute a given instruction for an n-element data set. We distinguish different cases for different situations - in the best case, in the worst case, and on average. Usually, the worst is given because it allows us to say "well, it won't get any worse."

So speaking even more simply, it's the number of steps needed to do something and how it grows when there's more of that something to do. There are different complexities - 1, log n, n, n*log n, n*n, and so on. I won't go into details; it would be a waste of time. Generally, the smaller this complexity, the faster the program.

In addition to the notation about "steps," there's also notation regarding, for example, memory/disk space. Analogously.

#### Data Structures

Here it's simple. Data structures are things that can significantly make our lives easier many times. They're simply some data arranged in a specific way. It's like a specific way of thinking about data. Here it's worth delving into details a bit.

What specific data structures did I recognize? Let me tell you.

1. Array - everyone knows, right?
2. Dictionary - same?
3. LinkedList - most people?
4. Stack
5. Heap
6. Set
7. Queue
8. Trees
9. HashTable
10. Trie

Although those last three are rather extra, above level I'd say. What's worth knowing here? What are the advantages/disadvantages of a given structure, when to use which. Computational or memory complexities for them and basic operations on them like searching, inserting, sorting. Similar to algorithms.

Again, I'll note that I haven't implemented practically any of these data structures myself - I just know approximately how most of them work and look. The only thing I implemented myself is a Linked List.

Anyway. This really comes in handy. Believe me.

### Tools

You need to be able to operate the tools needed for work, period. What was that in my case?

**IDE** - PyCharm as well as Vim. Currently, I use practically only PyCharm and now also Sublime. Before, it was Vim with plugins, but... with a larger project, PyCharm is simply more comfortable for me.

**Python** - what is virtualenv, pip, and all that? What for, why? And pipenv? Pypi?

**Virtualbox/WSL** - again, it's worth learning a bit about what it's about because they're useful tools, especially when working on several larger projects.

### Glossary

And now I'll throw in some various general terms from the broadly understood industry. Do you have to know each of them and have used a given tool, etc.? No, but it's nice to at least recognize them. It gives you an overview, and when talking with other people, perhaps more experienced, certain terms will be familiar, at least some of them. Then, instead of some incomprehensible jargon, you hear minimally familiar babble :D

1. VPS - in short, virtual private server, your own piece of some server, you could say
2. VPN - virtual private network, a kind of private network you could say
3. Docker, Vagrant - the first one I just know the name and that it's something with servers and app deployment, and the second one you can read about because it's a cool tool
4. HTTP, HTTPS, SSL, SSH, IMAP, POP3 protocols (!) - just superficially which goes to what and how they differ
5. IDE - integrated development environment
6. MVC - model, view, controller - a data processing model used in quite a lot of modern frameworks
7. API - application programming interface (!)
8. Cookie, Session, Cache - cookies, session, cache storage
9. MySQL, Postgres, MongoDB, Oracle, SQLite, SQL, NoSQL, SQL injection - (!) databases, a necessity in most applications
10. HTTP codes: 2xx, 3xx, 4xx, 5xx, but in practice you basically need: 200, 201, 301, 302, 400, 404, 500
11. AJAX, JS, ECMAScript, TypeScript, React, Vue - JavaScript, those things, you know
12. Class, Method, Object-orientation, object-oriented programming, functional programming, OOP (!!!) Generally, OOP is important
13. CMS - content management system
14. DDOS, DOS - such attacks by bad hackers
15. VCS - version control system, e.g., GIT
16. DevOps - what we do here
17. DOM - document object model - a necessity for JS devs
18. DRY, KISS, YAGNI (!!) - 3 principles worth following when creating code
19. Linux, Bash - Linux is an operating system, Bash is a scripting language, simplified
20. Framework, library - differences between them, is it the same thing?
21. Unit test, functional test, (!!) - unit and functional tests, more about them below
22. Hash, crypto - what is this hash, cryptography - what does it even deal with
23. Machine code, binary, hex - machine code, binary, hex. Various number systems useful because computers use them, not decimal
24. Production, dev, QA, localhost - production, meaning the server where the actual client's site/app runs, dev - development environment, local, localhost, QA/testing - for testing you could say, before it goes to production, although as they say, the best tests are only on production. Seriously though, no, don't try this at home.
25. Segfault - segmentation fault, what happens when you don't quite get it in a low-level language, or less often, in a high-level one
26. Bluescreen - you probably know :-)
27. Memory leak - google it
28. Integer overflow - same
29. Server - we put and run various apps/sites there (greatly simplified) and they live there
30. Spaghetti code - simply code that is terrible
31. TDD - test-driven development, DDD - domain-driven development, just a curiosity
32. Firewall - probably no need to explain
33. Compiler, linker, interpreter, assembly
34. Design pattern, the Big 4/Gang of Four
35. PNG, JPG, GIF, image sprite - file formats, greatly simplified
36. IP, TCP, PORT, Apache, Nginx, Gunicorn
37. Bootstrap, jQuery, Material Design, Gulp
38. Asynchronicity

A lot? Not really, because most of it should have come up at some point. Again - it's about simply recognizing these terms and knowing what's what.

Most of them are explained here: https://www.hackterms.com/ and if not there? Google. Or DuckDuckGo, whatever you prefer.

### Programming Languages

Alright, now it's time to talk about the languages themselves.

In my case, it's Python. What specifically did I know?

First, let's start with familiarity with Python's standard library. I was at least superficially familiar with it. What does that mean? Well, when I wanted to sort something, I didn't write a function myself; I just used sort() or sorted(), depending on the case, and that's it. It's about general orientation - here you have a list: https://docs.python.org/3/library/index.html Everything? Absolutely not, you just need to recognize some things, no one expects you to know it by heart. Browse the documentation; the official Python or Django documentation is great.

What to focus on? Basic data types, structures in Python, most commonly used functions, what OOP looks like in Python, what generators are, iterators, list/dict comprehensions, f-strings, reading and writing files, opening a link using Python, what GIL is and multithreading in Python, datetime, collections.

How? Simply by using it in practice - do several diverse projects, read other people's code, see how someone solves a given problem, compare it with your idea.

Besides that, I had experience with such Python libraries as BeautifulSoup and Selenium.

There's also C - but only basics that I grasped in CS50. Just for learning how certain things look at a lower level.

In addition, I know HTML5/CSS3 at a level that allows me to independently create simple templates/modify more complex ones.

JavaScript - here I basically google everything, but it's nice if you make, I don't know, a script changing the content of a div on a page, or something, to see how it works. Also remember that often just JS is enough; you don't need a gazillion libraries.

With jQuery, same as JavaScript - I don't know much, I google everything as needed. The key is knowing how to include jQuery in HTML, the rest is Google. In 2024, I probably wouldn't bother with it though. The JS API has grown and developed compared to 2017 when I was starting.

### Frameworks

A bit about which ones I had experience with.

Django, Flask, long ago web2py, WordPress. Am I a master in each of them? Absolutely not - in none of them, but if I take the documentation, I can already create something independently, at least in the first two.

If I were you, I'd aim for two - Django and FastAPI. But that's a personal note; I'm not a fan of Flask.

### Design Patterns

You're probably using them but don't even know it, and that's normal. It's about recognizing that something like this exists. My knowledge was more or less limited to that back then. Maybe I could name a few by name; you can read more. Singleton. Factory. Things like that.

### Testing

Well, there's such a thing. What does it look like? Is it about clicking through an app? Not always. It's nice to know what unit tests, functional tests, integration tests, and such are. Do you need to be proficient in them and know how to write them? No, actually most programmers don't really understand them that well, but it's always a plus, and a fairly big one.

### Operating Systems

If you've heard that there's something like Linux, that's good. If not, that's not too bad either. You've definitely heard because I wrote about it earlier. Honestly, it's highly dependent on your job whether you'll need it, but in my opinion, it's good to know at least some basics at the beginning. I'm not telling you to install Gentoo or something right away, but if you can navigate the system using the console, create, move or rename a file, delete it using the Linux (or Windows) console, that would be great. So we're safe after reading this book.

As for me, I just used Linux daily, but it's not necessary. What specifically? Manjaro (mainly), Solus, Ubuntu. For the latter, I even created a package with PyCharm Community Edition because it wasn't in the repo since it was a new project. Do you have to too? No. As I wrote above, it's enough to know how to navigate, because what if you have to do something via SSH, even on a VPS, and what? Too bad. But this way, boom, you know how.

Although now, for example, I don't use Linux at all because I work on a Mac; before that, it was Windows with WSL - that's just how it worked out at my job. Just saying, to emphasize once again that knowing Linux isn't necessary but veeeery useful.

But let's say you're ambitious. What then? Commands: **cd, ls, touch, mv, cp, ps, kill, rm, man, echo, grep, cat, chown, cat, sed** Plus how to install packages in a given distro, how to update.

That's all.

### Speaking of Systems

Let's talk about things a bit lower level. Yes, those terrible, archaic things. Yup. Well, imagine that my understanding of computer science, programming, and general concepts increased significantly after I grasped these basics a bit.

How the computer represents everything in memory, what that memory looks like, stack and heap, differences between them, when we use which. What data structures look like, why we index arrays from 0 and not 1, what the linked list looks like from the inside, counting in binary, hex.

What assembler is, what the compilation process looks like, what difference there is between compiled and interpreted languages, static versus dynamic typing.

Sounds boring, but these basics will let you become simply better programmers. You can not know this and still find a job, but the question is: do we want to be broadly understood specialists or just code monkeys from templates?

This knowledge about how it works from the low-level side actually helped me in the interview for my current job.

It's also worth knowing how to do certain things in the console - outside of the IDE. You'll better understand the mechanisms of some tools then.

### Debugging

When something goes wrong, you have to fix it.

Get at least minimally familiar with the debugger, get to know debugging methods.

Because besides the debugger, you can also do things a bit differently - the rubber duck method or the "XD" method. Cool stuff. What do they involve?

The first one is about explaining to someone, something, implicitly a rubber duck, how your program should work step by step. At some point, it might click that AHA! I wrote it differently, or you also compare it with the code and look if that's actually the case.

And the "XD" method? It's nothing other than the regular print method - you add lines to the code that print certain data, some characteristic message, so it's easy to find in logs, and then you look where it breaks. For me, that characteristic message is usually "XD" because I'm a follower of that philosophy, but whatever.

The last option is going through your code step by step and taking on the role of the computer - you execute instructions exactly as written, not thinking too much, and for example, substituting values on a piece of paper.

So yeah. Get familiar with the debugger. The so-called debugger.

### Good Practices

This is mainly about code organization, naming variables, and so on. Variables should be named concisely but precisely, descriptively, specifically. What does variable x do? No one knows, you'll forget too, but if the variable is called number_of_clients, that tells us something.

Speaking of names, there are different methodologies for naming variables, methods, classes. Camel case, underscore, and so on. Which one? Doesn't matter, as long as you stick to one consistently. Read PEP8.

Functions you write shouldn't be too long either - don't stuff everything into one bag. Break problems into smaller elements, split them up, and program in a way that allows them to be reused without repeating code.

Think about cases where the user might not behave as you expect. In general, think before you start programming. Programming is actually mainly thinking and then writing. Analyze the problem, consider various cases, and only then start implementing. You'll go faster and create better code than if you just started writing without thinking.

Keep the code fairly simple and flat, nicely divided. Complicated inheritance and millions of abstractions won't be your friend.

Take care of code readability, file names, consistency.

### VCS - About Git

What VCS is and why you need it, I won't go into, but one thing is obvious.

You need to know Git. And if you don't? You might get somewhere, but probably to a company you should run from. It's not hard, learn it. Git commit, merge, branch, checkout, push, pull, rebase. I think that's all you need for a start; that's enough for me.

### Projects

In Flask, I did two, let's say, normal projects - one somewhat more elaborate blog (adding posts, editing, comments, upvotes, tags, search, and so on) and a simple emulation of the simplest blockchain in history, and that's incomplete.

In Django, also about two, but a bit bigger - a manga reader, a school diary. So basically just CRUDs.

Plus a script in JS+Python - I like Asnyk's poems, so with Python I scraped his collection of works from the web using BeautifulSoup, put it into .txt in the appropriate format (CSV), and then with JS generated random poems from it, exposing them to the world via HTML.

Besides that, I once made a simple coordinate system - you type in some formula, and the script draws it in the browser, with functions like graph translation, reflection, symmetry, etc. My math teacher in high school was very pleased. Kind regards to her.

What else...

Three sites on commission - simple. I'd get some template, do minor or major edits, and boom, done. A classic landing page.

One was a typical LP.

The second similar, but with Flickr gallery integration.

The third was a bit different - landing page, gallery + a statically generated Jekyll blog dedicated to that site.

And actually, my simple blog, but that's a default Jekyll template slightly modified, so there's nothing to write about. What's important, however, is the fact that I had something written - some simple articles, but I'll describe them shortly.

I hosted everything on gh-pages to save on hosting :D By the way, it's quite a convenient way to host landing pages.

Besides that, I once made maybe two or three sites on WordPress, but when was that, I don't even remember, so I didn't include it in my CV. I also handled the server because I hosted my app on a VPS myself, or set up CS servers back in elementary school days.

### Blog

Mine wasn't too rich, but it was there. A few articles are there. That's like a little plus because it shows that I'm actually doing something, I'm interested, and so on. When I was recruiting and a candidate had an interesting blog, there was always a small plus.

What specifically was on it? 6 short articles on technical/related topics and a few less related to programming.

Oh, and a pro tip: read some industry blogs/forums, news, what's happening in the world. You need to stay fresh with news, because if not, you'll fall out of the loop. So much changes here in a year that it's mind-boggling.

### GitHub

Definitely create one and put some projects on it. A very big plus if you don't have commercial experience and don't know what to put in your CV - just fill it with some projects and that's it ;)

But if you're going to put crap just to have it, maybe reconsider.

### Summary

Above I've included information summarizing what I knew when I went to interviews. Most of this you can learn thanks to CS50 (C, Python, Linux, algorithms/structures, etc.) on edX - I sincerely recommend it to every beginner. And then what? Projects, projects, and projects.

Of course, a note: the above text is full of truly significant simplifications, but what can you do. I probably forgot about some things too, but oh well. I don't consider myself any authority, which is why I repeatedly state in this post that it's just my opinion and description of my knowledge state when I went to my first interview, not some absolute or benchmark. So treat everything written here with some distance. I've only been working since December, and the above is just a description of my skills when I went for an interview.

\pagebreak
